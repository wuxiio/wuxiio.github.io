---
title: 利用GitHub Actions自动构建项目的docker镜像并发布到DockerHub
date: 2022-07-23 11:01:57
permalink: /pages/5baf0a/
categories:
  - 运维观止
  - GitHub
tags:
  -
feed:
  enable: true
description: 做一个开源项目，尽量提供给受众以简单易用的快速上手体验，也是项目能够立刻把人抓住的一个关键。现在如果想让用户快速体验项目，除了提供demo环境之外，还有一个方案，那就是提供一个完备的docker-compose，让人能够直接一键拉起。
---


## 前言

做一个开源项目，尽量提供给受众以简单易用的快速上手体验，也是项目能够立刻把人抓住的一个关键。现在如果想让用户快速体验项目，除了提供demo环境之外，还有一个方案，那就是提供一个完备的docker-compose，让人能够直接一键拉起。

> 注意：是docker-compose，而非k8s的yml，尽管生产环境直接用docker-compose的很少，但是作为中间阶段，快速部署一个项目体验，而又不需要过多基础环境配置的场景来说，优势还是很大的。

于是，项目应该配套提供好对应的镜像，而由于现在Mac新CPU架构越来越多，因此提供的镜像最好又是能够支持多CPU架构运行的。

本文就来讲一下，如何借助 Github Actions 自动构建兼容多CPU架构的docker镜像并发布到DockerHub。

## 配置

所用 Actions： [build-push-action](https://github.com/docker/build-push-action)
多CPU架构镜像构建的流程文档：[利用buildx构建支持多CPU架构平台的docker镜像](https://wiki.eryajf.net/pages/95cf71/) ,此内容提供基础知识参考，后边构建不需要了解过多。

使用配置其实非常简单，基本上阅读完官方介绍文档就可以上手使用了，这里说一两个需要注意的地方。

首先添加 Actions 配置文件，e.g. `.github/workflows/docker-image.yml`：


```yaml
# This is a basic workflow to help you get started with Actions
name: build docker image
# Controls when the action will run.
on:
  push:
    branches:
      - main
# Allows you to run this workflow manually from the Actions tab
  # 可以手动触发
  workflow_dispatch:
    inputs:
      logLevel:
        description: 'Log level'
        required: true
        default: 'warning'
      tags:
        description: 'Test scenario tags'

jobs:
  buildx:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2

      - name: Get current date
        id: date
        run: echo "::set-output name=today::$(date +'%Y-%m-%d_%H-%M')"

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v1

      - name: Set up Docker Buildx
        id: buildx
        uses: docker/setup-buildx-action@v1

      - name: Available platforms
        run: echo ${{ steps.buildx.outputs.platforms }}

      - name: Login to DockerHub
        uses: docker/login-action@v1
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push
        uses: docker/build-push-action@v2
        with:
          context: .
          file: ./Dockerfile
          # 所需要的体系结构，可以在 Available platforms 步骤中获取所有的可用架构
          platforms: linux/amd64,linux/arm64/v8
          # 镜像推送时间
          push: ${{ github.event_name != 'pull_request' }}
          # 给清单打上多个标签
          tags: |
            eryajf/go-ldap-admin-server:${{ steps.date.outputs.today }}
            eryajf/go-ldap-admin-server:latest
```

很多配置见名知意，对照官方文档也都能找到答案，这里就不多赘述。

这里对几个关键的配置项做一下单独说明：

- DOCKERHUB_TOKEN的配置这里就不赘述了，在项目的setting中进行配置，已经多次讲过，这里留下此token创建的地址：[https://hub.docker.com/settings/security](https://hub.docker.com/settings/security)
- `file:`指定在项目仓库中的Dockerfile文件位置。
- `platforms：`指定构建镜像所需要兼容支持的平台架构，通常amd，arm就够了。
- `tags:`将要构建的镜像标签，此处我定义的是，每次构建时，提交一个该镜像时间戳的标签，再覆盖一下latest的标签，这样提供给docker-compose就直接用latest标签，可以保障每个新用户体验拉起的时候都是最新的镜像。

最后构建的镜像效果如下：

![image_20220723_105957](https://cdn.staticaly.com/gh/eryajf/tu/main/img/image_20220723_105957.png)

这里也可以看到推上去的镜像都是兼容两个CPU架构平台的。

## 补充

以上给出的配置示例，是当项目 main 分支有代码提交之后触发，有时候你可能会觉得这样每次打包会比较频繁，希望把打镜像的操作与 tag 对齐，那么可以通过如下配置进行：

::: v-pre
```yaml
name: build_docker

on:
  push:
    branches: [main]
  release:
    types: [created] # 表示在创建新的 Release 时触发

jobs:
  build_docker:
    name: Build docker
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      - name: Login to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push
        id: docker_build
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ./Dockerfile
          push: true
          platforms: linux/amd64,linux/arm64
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/${{ GITHUB_REPOSITORY_NAME_PART }}:${{ github.ref_name }}
            ${{ secrets.DOCKERHUB_USERNAME }}/${{ GITHUB_REPOSITORY_NAME_PART }}:latest
```
:::

::: v-pre
此处添加了触发时机，重要的在最后，我们使用 `${{ github.ref_name }}` 来拿到 github 当次触发的来源，如果是分支 push，则这个值为 main，如果是创建了一个 `v0.0.1` 的tag，则这个值为 `v0.0.1`。
:::

## 发布到ghcr

ghcr.io是GitHub官方的容器仓库，如果你想将镜像发布到ghcr，则可通过如下内容进行发布：

```yml
name: build_docker

on:
  push:
    branches: [main]
  release:
    types: [created,published] # 表示在创建新的 Release 时触发

jobs:
  build_docker:
    name: Build docker
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Inject slug/short variables
        uses: rlespinasse/github-slug-action@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      # Create Docker Image in Github
      - name: Login to the GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build And Push
        uses: docker/build-push-action@v3
        with:
          context: .
          push: true
          platforms: linux/amd64,linux/arm64
          tags: |
            ghcr.io/${{ secrets.DOCKERHUB_USERNAME }}/${{ env.GITHUB_REPOSITORY_NAME_PART }}:${{ env.GITHUB_REF_NAME }}
            ghcr.io/${{ secrets.DOCKERHUB_USERNAME }}/${{ env.GITHUB_REPOSITORY_NAME_PART }}:latest
```